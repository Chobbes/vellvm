(* -------------------------------------------------------------------------- *
 *                     Vellvm - the Verified LLVM project                     *
 *                                                                            *
 *     Copyright (c) 2017 Steve Zdancewic <stevez@cis.upenn.edu>              *
 *                                                                            *
 *   This file is distributed under the terms of the GNU General Public       *
 *   License as published by the Free Software Foundation, either version     *
 *   3 of the License, or (at your option) any later version.                 *
 ---------------------------------------------------------------------------- *)

From Coq Require Import
     ZArith
     List
     String
     Setoid
     Morphisms
     Omega.

From ExtLib Require Import
     Core.RelDec
     Programming.Eqv
     Structures.Monads.

From ITree Require Import 
     ITree
     Eq.Eq.

From Vellvm Require Import
     Util
     MemoryAddress
     DynamicValues
     Error.

Set Implicit Arguments.
Set Contextual Implicit.

Inductive dtyp : Set :=
| DTYPE_I (sz:Z)
| DTYPE_Pointer
| DTYPE_Void
| DTYPE_Half
| DTYPE_Float
| DTYPE_Double
| DTYPE_X86_fp80
| DTYPE_Fp128
| DTYPE_Ppc_fp128
| DTYPE_Metadata
| DTYPE_X86_mmx
| DTYPE_Array (sz:Z) (t:dtyp)
| DTYPE_Struct (fields:list dtyp)
| DTYPE_Packed_struct (fields:list dtyp)
| DTYPE_Opaque
| DTYPE_Vector (sz:Z) (t:dtyp)     (* t must be integer, floating point, or pointer type *)
.

Module Type LLVM_INTERACTIONS (ADDR : MemoryAddress.ADDRESS).

Global Instance eq_dec_addr : RelDec (@eq ADDR.addr) := RelDec_from_dec _ ADDR.addr_dec.
Global Instance Eqv_addr : Eqv ADDR.addr := (@eq ADDR.addr).  

(* The set of dynamic types manipulated by an LLVM program.  Mostly
   isomorphic to LLVMAst.typ but
     - pointers have no further detail
     - identified types are not allowed
   Questions:
     - What to do with Opaque?
*)

Module DV := DynamicValues.DVALUE(ADDR).
Export DV.

(* IO Interactions for the LLVM IR *)
Inductive IO : Type -> Type :=
| Alloca : forall (t:dtyp), (IO dvalue)
| Load   : forall (t:dtyp) (a:dvalue), (IO dvalue)
| Store  : forall (a:dvalue) (v:dvalue), (IO unit)
| GEP    : forall (t:dtyp) (v:dvalue) (vs:list dvalue), (IO dvalue)
| ItoP   : forall (i:dvalue), (IO dvalue)
| PtoI   : forall (a:dvalue), (IO dvalue)
| Call   : forall (t:dtyp) (f:string) (args:list dvalue), (IO dvalue)
.    


(* Trace of events generated by a computation. *)
Definition Trace X := itree IO (err X).

Global Instance exn_trace : (MonadExc string Trace) :=
  {| raise := fun _ s => Ret (inl s);
     catch := fun _ e k => match e.(observe) with
                        | RetF (inl e) => k e
                        | _ => e
                        end
  |}.

(* Lift the error monad into the trace monad. *)
Definition lift_err {A X} (f: A -> Trace X) : err A -> Trace X :=
  fun m => match m with
  | inl s => Ret (inl s)
  | inr b => f b
  end.


Definition bind_trace := fun {A B} t (k : A -> Trace B) => ITree.bind t (lift_err k).

Global Instance monad_trace : (Monad Trace) | 0 :=
  { ret X x := Ret (inr x);
    bind := fun A B => @bind_trace A B
  }.

Lemma bind_of_ret : forall A B (a:A) (k : A -> Trace B),
    bind (ret a) k ≅ k a.
Proof.
  intros A B a k.
  cbn. 
  econstructor. cbn.
  reflexivity.
Qed.


Lemma ret_of_bind : forall A (a:A) (t:Trace A),
    bind t (fun x => ret x) ≅ t.
Proof.
  cofix ch.
  intros A a t. cbn.
  econstructor. cbn. destruct (observe t).
  - destruct r; cbn; econstructor.
  - econstructor. apply ch. assumption.
  - econstructor. intros.  apply ch. assumption.
Qed.

Lemma bind_associativity : forall A B C (t : Trace A) (k : A -> Trace B) (h : B -> Trace C),
    bind (bind t k) h ≅ bind t (fun a => bind (k a) h).
Proof.
  cofix ch.
  intros A B C t k h.
  cbn. econstructor.
  cbn. destruct (observe t).
  - destruct r; cbn; try econstructor. reflexivity.
  - econstructor. unfold bind in ch. cbn in ch. unfold bind_trace, ITree.bind in ch. apply ch.
  - econstructor. intros y. unfold bind in ch. cbn in ch. unfold bind_trace, ITree.bind in ch. apply ch.
Qed.    

Lemma raise_bind : forall A B (s:string) (k : A -> Trace B),
  bind (raise s) k ≅ (raise s : Trace B).
Proof.
  intros A B s k.
  cbn. constructor. cbn. reflexivity.
Qed.


Instance Proper_bind {A B} :
  Proper (eq_itree ==> pointwise_relation _ eq_itree ==> eq_itree)
         (@bind_trace A B).
Proof.
  intros t1 t2 Ht k1 k2 Hk.
  generalize dependent t1.
  generalize dependent t2.
  cofix ch.
  intros t2 t1 Ht.
  constructor.
  unfold bind_trace.
  inversion Ht. cbn.
  inversion observe_eq.
  - destruct x. econstructor. cbn. apply Hk.
  - econstructor. unfold bind_trace, ITree.bind in ch. apply ch. assumption.
  - econstructor. intros y. unfold bind_trace, ITree.bind in ch. apply ch. apply H1.
Qed.    

(* Trace Utilities ---------------------------------------------------------- *)
Notation "'do' x <- m ;; f" := (lift_err (fun x => f) m)
                                (at level 100, x ident, m at next level, right associativity).

End LLVM_INTERACTIONS.

  
Module Make(ADDR : MemoryAddress.ADDRESS) <: LLVM_INTERACTIONS(ADDR).
Include LLVM_INTERACTIONS(ADDR).
End Make.
