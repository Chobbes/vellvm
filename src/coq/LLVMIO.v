(* -------------------------------------------------------------------------- *
 *                     Vellvm - the Verified LLVM project                     *
 *                                                                            *
 *     Copyright (c) 2017 Steve Zdancewic <stevez@cis.upenn.edu>              *
 *                                                                            *
 *   This file is distributed under the terms of the GNU General Public       *
 *   License as published by the Free Software Foundation, either version     *
 *   3 of the License, or (at your option) any later version.                 *
 ---------------------------------------------------------------------------- *)

Require Import ZArith List String Omega.
Require Import Vellvm.Classes Vellvm.Util Vellvm.Trace.
Require Import Vellvm.LLVMAst Vellvm.LLVMBaseTypes.

Set Implicit Arguments.
Set Contextual Implicit.

Module Type ADDR.
  Parameter addr : Set.
  Parameter null : addr.
(*  Parameter addr_dec : forall a1 a2:addr, {a1 = a2} + {a1 <> a2}. *)
End ADDR.  

(* The set of dynamic types manipulated by an LLVM program.  Mostly
   isomorphic to LLVMAst.typ but
     - pointers have no further detail
     - identified types are not allowed
   Questions:
     - What to do with Opaque?
*)
Inductive dtyp : Set :=
| DTYPE_I (sz:int)
| DTYPE_Pointer
| DTYPE_Void
| DTYPE_Half
| DTYPE_Float
| DTYPE_Double
| DTYPE_X86_fp80
| DTYPE_Fp128
| DTYPE_Ppc_fp128
| DTYPE_Metadata
| DTYPE_X86_mmx
| DTYPE_Array (sz:int) (t:dtyp)
| DTYPE_Function (ret:typ) (args:list dtyp)
| DTYPE_Struct (fields:list dtyp)
| DTYPE_Packed_struct (fields:list dtyp)
| DTYPE_Opaque
| DTYPE_Vector (sz:int) (t:dtyp)     (* t must be integer, floating point, or pointer type *)
.


Module DVALUE(A:ADDR).
       
(* The set of dynamic values manipulated by an LLVM program. *)
Inductive dvalue : Set :=
(* | DVALUE_FunPtr (fid : function_id) *)
| DVALUE_Addr (a:A.addr)
| DVALUE_I1 (x:int1)
| DVALUE_I32 (x:int32)
| DVALUE_I64 (x:int64)
| DVALUE_Double (x:ll_double)
| DVALUE_Float (x:ll_float)
| DVALUE_Undef (t:dtyp) (* (v:option exp) *)
| DVALUE_Poison
| DVALUE_None
| DVALUE_Struct        (fields: list (dtyp * dvalue))
| DVALUE_Packed_struct (fields: list (dtyp * dvalue))
| DVALUE_Array         (elts: list (dtyp * dvalue))
| DVALUE_Vector        (elts: list (dtyp * dvalue))
.

Definition undef t := DVALUE_Undef t.
Definition undef_i1  := undef (DTYPE_I 1).
Definition undef_i32 := undef (DTYPE_I 32).
Definition undef_i64 := undef (DTYPE_I 64).

Inductive IO : Type -> Type :=
| Alloca : forall (t:dtyp), (IO dvalue)
| Load   : forall (t:dtyp) (a:dvalue), (IO dvalue)
| Store  : forall (a:dvalue) (v:dvalue), (IO unit)
| GEP    : forall (t:dtyp) (v:dvalue) (vs:list dvalue), (IO dvalue)
| ItoP   : forall (i:dvalue), (IO dvalue)
| PtoI   : forall (a:dvalue), (IO dvalue)
| Call   : forall (t:dtyp) (f:string) (args:list dvalue), (IO dvalue)
| DeclareFun : forall (f:function_id), (IO dvalue)
.    

(* Trace of events generated by a computation. *)
Definition Trace X := M IO X.
Instance functor_trace : Functor Trace := (@mapM IO).
Instance monad_trace : (@Monad Trace) (@mapM IO) := { mret X x := Ret x; mbind := @bindM IO }.
Instance exn_trace : (@ExceptionMonad string Trace _ _) := fun _ s => Err s.

(* Trace Utilities ---------------------------------------------------------- *)

(* Lift the error monad into the trace monad. *)
Definition lift_err_d {A X} (m:err A) (f: A -> Trace X) : Trace X :=
  match m with
  | inl s => raise s
  | inr b => f b
  end.

Notation "'do' x <- m ; f" := (lift_err_d m (fun x => f)) 
                               (at level 200, x ident, m at level 100, f at level 200).

End DVALUE.